ja: zelim automatizirati PR tako da ga AI pregleda
ti: Mentalni model (big picture)
Cilj ti je ovo:
PR otvoren â†’ pipeline se pokrene â†’ AI proÄita diff â†’ AI napiÅ¡e review â†’ komentar se pojavi u PR-u
TehniÄki gledano, trebaÅ¡ spojiti 4 stvari:
1.	Bitbucket event (PR created / updated)
2.	Kod koji skuplja diff
3.	AI model koji analizira kod
4.	Bot koji komentira PR
________________________________________
1ï¸âƒ£ Odakle krenuti (minimal viable setup)
PreporuÄeni start:
ğŸ‘‰ Bitbucket Pipelines + OpenAI API (ili drugi LLM)
ZaÅ¡to?
â€¢	Pipelines veÄ‡ imaÅ¡ uz git
â€¢	Ne moraÅ¡ hostati server
â€¢	Sve se dogaÄ‘a â€œautomatskiâ€
________________________________________
2ï¸âƒ£ Trigger: kad se AI review pokreÄ‡e
ImaÅ¡ dvije opcije:
Opcija A â€” Bitbucket Pipelines (najÄeÅ¡Ä‡e)
Pipeline se pokreÄ‡e:
â€¢	kad se otvori PR
â€¢	kad se PR updatea (novi commit)
U bitbucket-pipelines.yml definiraÅ¡:
â€¢	trigger: pull-request
â€¢	skriptu koja:
o	povuÄe diff
o	poÅ¡alje ga AI-ju
o	poÅ¡alje komentar natrag
âœ… najjednostavnije
âŒ manje fleksibilno
________________________________________
Opcija B â€” Webhook + vlastiti servis
Bitbucket â†’ webhook â†’ tvoj server â†’ AI â†’ Bitbucket API
âœ… maksimalna kontrola
âŒ viÅ¡e posla
Za prvi pokuÅ¡aj: Opcija A.
________________________________________
3ï¸âƒ£ Kako AI â€œvidiâ€ PR
U pipelineu:
1.	checkout repo
2.	izvuÄeÅ¡ diff izmeÄ‘u:
o	target branch (npr. main)
o	PR branch
Primjeri inputa za AI:
â€¢	git diff origin/main...HEAD
â€¢	samo promijenjeni fajlovi
â€¢	samo .js, .py, itd.
ğŸ’¡ Nemoj slati cijeli repo â€” samo diff.
________________________________________
4ï¸âƒ£ Kako izgleda prompt za AI (kljuÄno!)
Nemoj samo:
â€œReview this codeâ€
Bolje neÅ¡to ovako (konceptualno):
You are a senior software engineer.
Review the following pull request diff.
Focus on:
â€¢	bugs
â€¢	security issues
â€¢	performance problems
â€¢	readability
â€¢	breaking changes
If everything looks fine, say so explicitly.
Output markdown suitable for a PR comment.
To je 80% kvalitete reviewa.
________________________________________
5ï¸âƒ£ Gdje AI piÅ¡e komentar
Bitbucket ima REST API:
â€¢	endpoint za PR comments
â€¢	trebaÅ¡:
o	repo
o	PR ID
o	auth token (bot user)
Pipeline:
â€¢	generira tekst
â€¢	POST na Bitbucket API
â€¢	komentar se pojavi kao da ga je napisao bot ğŸ¤–
________________________________________
6ï¸âƒ£ Kako to izgleda u praksi (flow)
PR opened
   â†“
Bitbucket Pipeline
   â†“
Extract git diff
   â†“
Send diff â†’ AI
   â†“
Receive review text
   â†“
POST comment to PR
Gotovo.
________________________________________
7ï¸âƒ£ Å to obavezno dodati (lessons learned)
ğŸ”’ Sigurnost
â€¢	API key u repo variables
â€¢	nikad u git
ğŸ“ Limiti
â€¢	veliki diff â†’ chunkaj
â€¢	ili review po fajlu
ğŸ§  Kontekst
â€¢	dodaj:
o	coding standards
o	jezik / framework
o	â€œovo je legacy codeâ€
ğŸš« Noise control
â€¢	neka AI:
o	ne komentira formatting
o	ne ponavlja obvious stvari
o	ne izmiÅ¡lja probleme
________________________________________
8ï¸âƒ£ Level-up ideje (kad proradi osnovno)
â€¢	AI only comments if:
o	score > X
o	found critical issues
â€¢	razliÄiti promptovi:
o	security review
o	performance review
â€¢	label PR-a:
o	ai-reviewed
â€¢	summary + inline comments
â€¢	â€œapprove / request changesâ€ signal
________________________________________
9ï¸âƒ£ Gotova rjeÅ¡enja (ako ne Å¾eliÅ¡ graditi sve)
Postoje alati (razne kvalitete):
â€¢	PR AI reviewers (komercijalni)
â€¢	Open-source GitHub-first (Bitbucket ponekad slabije podrÅ¾an)
Ako Å¾eliÅ¡ full kontrolu i privatnost â†’ DIY je bolji.
________________________________________
Kako dalje?
Mogu ti:
â€¢	sloÅ¾iti konkretan bitbucket-pipelines.yml
â€¢	napisati toÄan prompt za tvoj stack
â€¢	predloÅ¾iti model + cijenu
â€¢	ili dizajnirati â€œAI reviewer rubricâ€ (Å¡to smije / ne smije komentirati)
Reci:
ğŸ‘‰ koji jezik / framework
ğŸ‘‰ koliko je velik repo
ğŸ‘‰ Å¾eliÅ¡ li POC ili â€œproduction-readyâ€ setup



ja: kako je najbolje to sve razviti i plasirati? (gh vs bitbucket)?
ti: TL;DR preporuka (ako Å¾eliÅ¡ odmah odgovor)
ğŸ‘‰ Razvij GitHub-first, ali arhitekturu drÅ¾i platform-agnostiÄnom.
ğŸ‘‰ Bitbucket dodaj kasnije kao differentiator, ne kao poÄetnu toÄku.
Sad zaÅ¡to i kako.
________________________________________
1ï¸âƒ£ GH vs Bitbucket â€” hladna realnost trÅ¾iÅ¡ta
ğŸ“Š GitHub
Prednosti
â€¢	Ogromna baza devova (default platform)
â€¢	GitHub Actions + Apps = savrÅ¡eno tlo za PR botove
â€¢	Devovi navikli instalirati botove
â€¢	Marketplace = distribucija + trust
â€¢	LakÅ¡e dobiti:
o	feedback
o	GitHub stars
o	open-source kontribucije
o	prve korisnike
Nedostatci
â€¢	Brutalna konkurencija
â€¢	ViÅ¡e â€œAI noise-aâ€
________________________________________
ğŸ“Š Bitbucket
Prednosti
â€¢	Manje konkurencije
â€¢	Enterprise / legacy timovi
â€¢	Jira / Atlassian ekosustav
â€¢	Ljudi Å¾ele AI, ali ga nemaju
Nedostatci
â€¢	Slabiji ekosustav
â€¢	Manje open-source publike
â€¢	TeÅ¾i onboarding
â€¢	Nema â€œMarketplace momentumaâ€ kao GH
________________________________________
ğŸ§  ZakljuÄak
Ako kreÄ‡eÅ¡ od nule â†’ GitHub-first je racionalan izbor.
Ako ciljaÅ¡ enterprise / naplatu â†’ Bitbucket postaje zlato kasnije.
________________________________________
2ï¸âƒ£ Kako razviti: arhitektura koja te ne zakljuÄa
ğŸ”‘ Zlatno pravilo
Core logika â‰  platform integracija
PredloÅ¾ena arhitektura
/core
  - diff parser
  - prompt builder
  - LLM adapter (OpenAI, Anthropicâ€¦)
  - review rules engine

/adapters
  /github
    - webhook handler
    - PR comment publisher
  /bitbucket
    - webhook handler
    - PR comment publisher

/cli
  - local testiranje
  - CI usage

/api (optional)
  - SaaS endpoint
Tako:
â€¢	review engine piÅ¡eÅ¡ jednom
â€¢	platforme samo â€œtankeâ€ adaptere
________________________________________
3ï¸âƒ£ Kako krenuti â€” preporuÄeni redoslijed
ğŸ¥‡ Faza 1 â€” GitHub Action (open-source)
ZaÅ¡to?
â€¢	NajbrÅ¾i time-to-value
â€¢	Minimalna infrastruktura
â€¢	Lak feedback loop
Napraviti:
â€¢	GitHub Action
â€¢	.github/workflows/ai-review.yml
â€¢	koristi OpenAI / Claude API
â€¢	komentira PR
â¡ï¸ Ovo ti je PoC + marketing alat.
________________________________________
ğŸ¥ˆ Faza 2 â€” GitHub App (semi-commercial)
Kad vidiÅ¡ da ljudi koriste:
â€¢	GitHub App
â€¢	webhook â†’ tvoj backend
â€¢	centralizirana logika
â€¢	billing (Stripe)
â¡ï¸ Ovo je proizvod.
________________________________________
ğŸ¥‰ Faza 3 â€” Bitbucket integracija
Sad si u prednosti:
â€¢	veÄ‡ imaÅ¡ stabilan core
â€¢	Bitbucket adapter je â€œsamoâ€ novi integration layer
â¡ï¸ Ovdje se naplaÄ‡uje ozbiljnije.
________________________________________
4ï¸âƒ£ Open-source vs commercial â€” pametna kombinacija
ğŸ§© Najbolji pattern (provjeren)
Open-core model
Dio	Status
Core PR review	open-source
Advanced rules	paid
Analytics	paid
Team policies	paid
Hosted service	paid
Ljudi:
â€¢	vjeruju open-sourceu
â€¢	plate za convenience
________________________________________
5ï¸âƒ£ Kako se plasirati (ne samo â€œobjavitiâ€)
ğŸ¯ GitHub-first distribucija
â€¢	README s GIF-om (kritiÄno)
â€¢	30-sek demo
â€¢	â€œBefore / After PRâ€
â€¢	GitHub Marketplace listing
ğŸ“£ Early traction
â€¢	Hacker News (Show HN)
â€¢	Reddit (r/programming, r/devops)
â€¢	LinkedIn (enterprise crowd)
â€¢	Dev Twitter
________________________________________
6ï¸âƒ£ Å to Ä‡e te razlikovati (ovo je bitno)
âŒ â€œAI reviews codeâ€ â€” svi to govore
âœ… Ovo prodaje:
â€¢	Signal > noise
â€¢	â€œComments only if confidence > Xâ€
â€¢	â€œNo style commentsâ€
â€¢	â€œSecurity-only modeâ€
â€¢	â€œExplain why, not whatâ€
Ljudi mrze spam u PR-ovima.
________________________________________
7ï¸âƒ£ Monetizacija â€” realne opcije
GitHub
â€¢	per repo / per seat
â€¢	$10â€“30 / dev / month
Bitbucket
â€¢	team / org pricing
â€¢	$100â€“500 / month
â€¢	lakÅ¡e dobiti approval
________________________________________
8ï¸âƒ£ Moj iskren savjet
Ako mi kaÅ¾eÅ¡:
â€¢	radiÅ¡ solo ili s timom
â€¢	Å¾eliÅ¡ open-source kredibilitet ili revenue
â€¢	ciljaÅ¡ devove ili management
mogu ti:
â€¢	nacrtati konkretan roadmap (0 â†’ 1 â†’ 10k ARR)
â€¢	pomoÄ‡i dizajnirati MVP feature set
â€¢	pomoÄ‡i oko naminga + positioning
Ali da odgovorim jasno na tvoje pitanje:
Razvij GitHub-first.
Plasiraj open-source.
Monetiziraj kroz GitHub App.
Bitbucket dodaj kad imaÅ¡ traction.


faza 1
Evo organizacijskog plana za FAZU 1 / Dan 1 â€” ne kod, nego kako toÄno strukturirati posao da zavrÅ¡iÅ¡ dan s âœ”ï¸ testom.
________________________________________
Cilj dana (jasno i mjerljivo)
Na kraju dana moÅ¾eÅ¡ napraviti:
git diff origin/main...HEAD | ai-review parse
i dobiti:
[
  {
    "path": "src/auth/login.ts",
    "language": "ts",
    "hunks": [
      {
        "oldStart": 12,
        "newStart": 14,
        "changes": [
          { "type": "add", "content": "if (!user) return null" }
        ]
      }
    ]
  }
]
Ako to radi â†’ Dan 1 je gotov.
________________________________________
Mentalna podjela dana (4 bloka)
BLOK 1 â€” Spec & granice (45â€“60 min)
Ne piÅ¡eÅ¡ kod odmah.
Odgovori (u biljeÅ¡ke / README):
â€¢	koje formate diffa podrÅ¾avaÅ¡:
o	âœ… unified diff (default git)
o	âŒ rename / binary (za sada)
â€¢	Å¡to ne parsiraÅ¡:
o	context-only hunks
o	binary files
â€¢	maksimalna odgovornost parsera:
o	Äitati diff
o	pretvoriti u strukturu
o	niÅ¡ta viÅ¡e
â¡ï¸ Ovo sprjeÄava scope creep.
________________________________________
BLOK 2 â€” Struktura /core/diff (30 min)
Napraviti minimalnu strukturu:
/core
  /diff
    - readDiff.ts
    - parseDiff.ts
    - filters.ts
    - types.ts
types.ts
DefiniraÅ¡ jedini canonical shape:
â€¢	DiffFile
â€¢	DiffHunk
â€¢	Change
ğŸ‘‰ Ovo je â€œugovorâ€ za cijeli core.
________________________________________
BLOK 3 â€” Implementacija po slojevima (2â€“3 h)
1ï¸âƒ£ readDiff
Jedna odgovornost:
â€¢	stdin
â€¢	ili file
â€¢	ili raw string
Output: string
Bez parsanja.
________________________________________
2ï¸âƒ£ parseDiff
Input: raw diff string
Output: DiffFile[]
RadiÅ¡:
â€¢	split po diff --git
â€¢	extract path
â€¢	extract hunks (@@ -x,y +a,b @@)
â€¢	linije:
o	+ â†’ add
o	- â†’ remove
o	space â†’ context
Ne optimiziraj.
Ne edge-caseaj.
Napravi da radi na 80% diffova.
________________________________________
3ï¸âƒ£ filters
Pipeline-style:
files
  â†’ removeLockFiles
  â†’ removeVendor
  â†’ removeGenerated
Rules hardcoded:
â€¢	package-lock.json
â€¢	yarn.lock
â€¢	vendor/
â€¢	dist/
â€¢	*.min.js
________________________________________
BLOK 4 â€” Manual test (30â€“45 min)
Napraviti:
â€¢	mali fake diff (2 fajla)
â€¢	jedan pravi PR diff iz vlastitog repa
Testirati:
â€¢	prazni diff
â€¢	samo lockfile diff
â€¢	normalan code diff
Output mora biti:
â€¢	validan JSON
â€¢	stabilan shape
â¡ï¸ Ako ovo proÄ‘e â†’ commit.
________________________________________
Checklist (copy-paste friendly)
Na kraju dana mora biti:
â€¢	DiffFile[] tip definiran
â€¢	parser radi na realnom diffu
â€¢	lock / vendor ignorirani
â€¢	CLI / script koji ispisuje JSON
â€¢	README: â€œHow diff parsing worksâ€
Ako neÅ¡to od ovoga fali â†’ dan nije gotov.
________________________________________
Å to SVJESNO ne radiÅ¡ danas
âŒ language detection (moÅ¾e kasnije)
âŒ perfect hunk ranges
âŒ rename detection
âŒ inline positions
âŒ performance tuning
Sve to je Dan 3+ problem.
________________________________________
Kako znaÅ¡ da si uspio
Ako sutra moÅ¾eÅ¡:
â€¢	uzeti isti JSON
â€¢	poslati ga prompt builderu
â€¢	bez da diraÅ¡ parser
â†’ arhitektura je Äista.
________________________________________
Ako Å¾eliÅ¡, sljedeÄ‡e mogu:
â€¢	pomoÄ‡i ti definirati toÄne TypeScript tipove
â€¢	predloÅ¾iti gotovu libu vs ruÄni parser (tradeoff)
â€¢	ili razbiti Dan 2 istim ovakvim planom
Reci samo.


blok 2
ğŸ‘‰ **BLOK 2 â€“ struktura /core/diff + Python dataclasses**
SavrÅ¡eno. Sad ulazimo u Äisti, mirni, deterministiÄki dio ğŸ˜„
BLOK 2 = postavljamo kostur koji se kasnije viÅ¡e ne dira.
IÄ‡i Ä‡u ovim redom:
1.	struktura foldera
2.	dataclasses (toÄan shape)
3.	kratka pravila kako se koriste
Bez implementacije parsanja joÅ¡.
________________________________________
1ï¸âƒ£ Struktura /core/diff
Minimalna, ali zdrava:
/core
  /diff
    __init__.py
    types.py        # dataclasses (kanonski model)
    read_diff.py    # Äitanje raw diff-a (stdin/file/string)
    parse_diff.py   # raw diff -> DiffFile[]
    filters.py      # ignore rules (lock, vendor, generated)
    README.md
Za BLOK 2 danas:
â€¢	radiÅ¡ samo types.py
â€¢	ostalo moÅ¾e biti prazno ili s TODO komentarom
________________________________________
2ï¸âƒ£ types.py â€” kanonski model (najbitniji file)
Ovo je ugovor za cijeli /core.
Ako je ovo Äisto, sve ostalo sjedne prirodno.
# core/diff/types.py

from dataclasses import dataclass
from enum import Enum
from typing import List, Optional


class ChangeType(str, Enum):
    ADD = "add"
    REMOVE = "remove"
    CONTEXT = "context"


@dataclass(frozen=True)
class Change:
    """
    Single line-level change inside a diff hunk.
    """
    type: ChangeType
    content: str


@dataclass(frozen=True)
class DiffHunk:
    """
    A contiguous block of changes in a file.
    """
    old_start: int
    old_length: int
    new_start: int
    new_length: int
    changes: List[Change]


@dataclass(frozen=True)
class DiffFile:
    """
    All changes related to a single file.
    """
    path: str
    hunks: List[DiffHunk]
    language: Optional[str] = None
ZaÅ¡to ovako (kratko, ali vaÅ¾no)
â€¢	frozen=True
o	nema mutiranja usred pipelinea
o	lakÅ¡e debugirati
â€¢	Enum za ChangeType
o	nema magic stringova
â€¢	language: Optional
o	parser ne mora znati jezik
o	moÅ¾e se dodati kasnije (ili u drugom layeru)
________________________________________
3ï¸âƒ£ Å to JE, a Å¡to NIJE odgovornost ovih tipova
âœ”ï¸ OVI TIPOVI RADE
â€¢	predstavljaju Å¡to se promijenilo
â€¢	mogu se JSON-izirati
â€¢	mogu se testirati bez git-a
âŒ OVI TIPOVI NE RADE
â€¢	ne znaju Å¡to je PR
â€¢	ne znaju line numbers u fajlu
â€¢	ne znaju je li neÅ¡to bug
â€¢	ne znaju kako se komentira kod
Ako se uloviÅ¡ da Å¾eliÅ¡ dodati:
â€¢	severity
â€¢	confidence
â€¢	comment
â†’ to je veÄ‡ drugi layer, ne diff.
________________________________________
4ï¸âƒ£ Mini sanity-check (bez pravog koda)
Ako moÅ¾eÅ¡ u Python REPL-u napraviti ovo:
from core.diff.types import DiffFile, DiffHunk, Change, ChangeType

diff = DiffFile(
    path="src/auth/login.py",
    hunks=[
        DiffHunk(
            old_start=10,
            old_length=2,
            new_start=10,
            new_length=4,
            changes=[
                Change(ChangeType.ADD, "if not user:"),
                Change(ChangeType.ADD, "    return None"),
            ],
        )
    ],
    language="python",
)
i niÅ¡ta ti ne smrdi â€” BLOK 2 je uspio.
________________________________________
5ï¸âƒ£ Checklist za BLOK 2
Na kraju ovog koraka:
â€¢	/core/diff/types.py postoji
â€¢	koristi @dataclass
â€¢	nema business logike
â€¢	README i tipovi se slaÅ¾u
â€¢	moÅ¾eÅ¡ ruÄno instancirati objekte
Ako je sve âœ”ï¸ â†’ commitaj odmah.
________________________________________
SljedeÄ‡i korak (BLOK 3 â€“ implementacija)
LogiÄan nastavak je:
ğŸ‘‰ read_diff.py (najlakÅ¡i dio)
â€¢	stdin
â€¢	file path
â€¢	raw string
Bez parsanja, bez pameti.
Ako Å¾eliÅ¡, mogu:
â€¢	dati toÄan skeleton za read_diff.py
â€¢	ili nastaviti ovim tempom: blok po blok, kao mini sprint
Reci kako Å¾eliÅ¡ nastaviti ğŸ‘Œ


blok 3
BLOK 3 = najÄiÅ¡Ä‡i moguÄ‡i komad posla. Ako ga napraviÅ¡ pravilno, nikad ga viÅ¡e ne diraÅ¡.
________________________________________
BLOK 3 â€” read_diff.py
Cilj bloka (jedna reÄenica)
Imati jedan naÄin da dobijeÅ¡ raw git diff string iz:
â€¢	stdin-a
â€¢	file-a
â€¢	veÄ‡ postojeÄ‡eg stringa
Bez parsanja. Bez logike. Bez pameti.
________________________________________
Mentalni model (bitno)
read_diff.py ne zna:
â€¢	Å¡to je git
â€¢	Å¡to je diff format
â€¢	Å¡to Ä‡e se s tim stringom dogoditi
On samo odgovara na pitanje:
â€œOdakle dolazi tekst?â€
________________________________________
API koji ciljaÅ¡ (prije koda)
Na kraju Å¾eliÅ¡ moÄ‡i raditi ovo:
from core.diff.read_diff import read_diff

raw = read_diff()
raw = read_diff(from_file="diff.txt")
raw = read_diff(from_string=some_diff)
ğŸ‘‰ uvijek vraÄ‡a str
Ako ne zna Å¡to da radi â†’ baca jasan exception.
________________________________________
Struktura file-a
/core/diff
  read_diff.py
________________________________________
Implementacija: read_diff.py
Ovo je gotov, finalni kod za BLOK 3.
# core/diff/read_diff.py

import sys
from typing import Optional


class DiffReadError(Exception):
    """Raised when diff input cannot be read."""


def read_diff(
    *,
    from_file: Optional[str] = None,
    from_string: Optional[str] = None,
) -> str:
    """
    Read a raw git diff from one of the supported sources.

    Priority:
    1. from_string
    2. from_file
    3. stdin

    Returns:
        Raw diff as a string.

    Raises:
        DiffReadError if no input is available or input is invalid.
    """

    if from_string is not None:
        if not isinstance(from_string, str):
            raise DiffReadError("from_string must be a string")
        return from_string.strip()

    if from_file is not None:
        try:
            with open(from_file, "r", encoding="utf-8") as f:
                return f.read().strip()
        except OSError as e:
            raise DiffReadError(f"Failed to read diff file: {e}") from e

    if not sys.stdin.isatty():
        data = sys.stdin.read().strip()
        if data:
            return data

    raise DiffReadError(
        "No diff input provided. Use from_string, from_file, or pipe via stdin."
    )
________________________________________
ZaÅ¡to je ovo â€œtoÄno ovakoâ€ (kratko, ali vaÅ¾no)
â€¢	named-only arguments (*)
o	sprjeÄava greÅ¡ke tipa read_diff("foo")
â€¢	jasan priority
o	nema implicitnog ponaÅ¡anja
â€¢	custom exception
o	kasnije je lako hendlati u CLI-ju
â€¢	.strip()
o	makne noise na rubovima
â€¢	nema git komandi
o	git je odgovornost adaptera / CLI-ja
________________________________________
Mini test (ruÄno, 5 min)
U Python REPL-u:
from core.diff.read_diff import read_diff

print(read_diff(from_string="diff --git a/a.py b/a.py\n+print('hi')"))
CLI test:
git diff | python -c "from core.diff.read_diff import read_diff; print(read_diff())"
Ako ispiÅ¡e diff â†’ BLOK 3 je gotov.
________________________________________
Checklist za BLOK 3
â€¢	read_diff.py postoji
â€¢	nema parsanja
â€¢	vraÄ‡a uvijek str
â€¢	baca jasan error ako nema inputa
â€¢	radi sa stdin pipe-om
âœ”ï¸ Commit.
________________________________________
SljedeÄ‡i korak (BLOK 4)
ğŸ‘‰ parse_diff.py
Tu Ä‡emo:
â€¢	uzeti raw string
â€¢	splitati po diff --git
â€¢	mapirati u DiffFile / DiffHunk / Change
To je najveÄ‡i blok u FAZI 1, ali sad imaÅ¡ sav temelj.
Kad si spreman, samo reci: â€œidemo BLOK 4â€ ğŸ‘Œ


DI Ognjen Feist
DevOps Engineer
Software Requirements & Architecture   
SAMSUNG SDI Battery Systems GmbH
Industriezeile 2, 8401 Kalsdorf bei Graz

Mobile: +43 664 8813 5729
E-Mail: o.feist@samsung.com
Website: www.samsungsdi.com
________________________________________________________________
Disclosure pursuant to Â§14 UGB:
Samsung SDI Battery Systems GmbH based in Graz
Commercial registry file number: FN 427124 z, court of jurisdiction: Landesgericht f. ZRS Graz
This message is not legally binding upon SDI Battery Systems GmbH!


blok 4
â€œidemo BLOK 4â€ ğŸ‘Œ
Ajmo ğŸ˜„
BLOK 4 = srce FAZE 1. Tu diff prestaje biti tekst i postaje struktura.
Idemo pragmatiÄno, bez over-engineeringa. Cilj je 80% diffova, Äisto i predvidljivo.
________________________________________
BLOK 4 â€” parse_diff.py
Cilj bloka
Imati funkciju:
parse_diff(raw_diff: str) -> List[DiffFile]
koja:
â€¢	uzima raw unified diff
â€¢	vraÄ‡a kanonske dataclasses
â€¢	ignorira Å¡to ne razumije
Bez filtera, bez AI-a, bez PR logike.
________________________________________
Mentalni model
Parser je jednosmjerni stroj:
raw diff (string)
  â†“
file blocks
  â†“
hunks
  â†“
line changes
  â†“
DiffFile[]
Ako neÅ¡to ne znaÅ¡ â†’ preskoÄi, nemoj pucati.
________________________________________
File structure
/core/diff
  parse_diff.py
________________________________________
Implementacija: parse_diff.py
Ovo je kompletan, radni parser za BLOK 4.
# core/diff/parse_diff.py

import re
from typing import List

from core.diff.types import DiffFile, DiffHunk, Change, ChangeType


DIFF_FILE_HEADER = re.compile(r"^diff --git a/(.+?) b/(.+)$")
HUNK_HEADER = re.compile(
    r"^@@ -(\d+)(?:,(\d+))? \+(\d+)(?:,(\d+))? @@"
)


def parse_diff(raw_diff: str) -> List[DiffFile]:
    if not raw_diff.strip():
        return []

    files: List[DiffFile] = []
    current_file = None
    current_hunks: List[DiffHunk] = []

    current_hunk_lines = []
    hunk_meta = None

    for line in raw_diff.splitlines():
        file_match = DIFF_FILE_HEADER.match(line)
        if file_match:
            if current_file:
                if hunk_meta and current_hunk_lines:
                    current_hunks.append(_build_hunk(hunk_meta, current_hunk_lines))
                files.append(
                    DiffFile(
                        path=current_file,
                        hunks=current_hunks,
                    )
                )

            current_file = file_match.group(2)
            current_hunks = []
            current_hunk_lines = []
            hunk_meta = None
            continue

        hunk_match = HUNK_HEADER.match(line)
        if hunk_match:
            if hunk_meta and current_hunk_lines:
                current_hunks.append(_build_hunk(hunk_meta, current_hunk_lines))

            hunk_meta = (
                int(hunk_match.group(1)),
                int(hunk_match.group(2) or 1),
                int(hunk_match.group(3)),
                int(hunk_match.group(4) or 1),
            )
            current_hunk_lines = []
           continue

        if hunk_meta:
            if line.startswith("+"):
                current_hunk_lines.append(
                    Change(ChangeType.ADD, line[1:])
                )
            elif line.startswith("-"):
                current_hunk_lines.append(
                    Change(ChangeType.REMOVE, line[1:])
                )
            elif line.startswith(" "):
                current_hunk_lines.append(
                    Change(ChangeType.CONTEXT, line[1:])
                )

    if current_file:
        if hunk_meta and current_hunk_lines:
            current_hunks.append(_build_hunk(hunk_meta, current_hunk_lines))
        files.append(
            DiffFile(
                path=current_file,
                hunks=current_hunks,
            )
        )

    return files


def _build_hunk(meta, changes):
    old_start, old_len, new_start, new_len = meta
    return DiffHunk(
        old_start=old_start,
        old_length=old_len,
        new_start=new_start,
        new_length=new_len,
        changes=changes,
    )
________________________________________
Å to parser namjerno ignorira
â€¢	index ...
â€¢	--- a/file
â€¢	+++ b/file
â€¢	\ No newline at end of file
â€¢	rename / binary markers
â¡ï¸ To je feature, ne bug.
________________________________________
Brzi ruÄni test (10 min)
Napraviti mali diff string:
from core.diff.parse_diff import parse_diff

diff = """
diff --git a/test.py b/test.py
@@ -1,1 +1,2 @@
print("hello")
+print("world")
"""

files = parse_diff(diff)
print(files)
OÄekujeÅ¡:
â€¢	1 file
â€¢	1 hunk
â€¢	2 changes (context + add)
________________________________________
Checklist za BLOK 4
â€¢	parse_diff vraÄ‡a DiffFile[]
â€¢	viÅ¡e fajlova radi
â€¢	viÅ¡e hunks po fajlu radi
â€¢	prazni diff â†’ []
â€¢	ne puca na noise
Ako je sve âœ”ï¸ â†’ commit.
________________________________________
Gdje smo sad
Do sada imaÅ¡:
â€¢	âœ”ï¸ jasnu spec (README)
â€¢	âœ”ï¸ kanonske dataclasses
â€¢	âœ”ï¸ input reader
â€¢	âœ”ï¸ diff â†’ struktura
To znaÄi:
ğŸ‘‰ FAZA 1 je praktiÄki gotova
Preostalo:
â€¢	BLOK 5 â€” filters.py
â€¢	BLOK 6 â€” manual end-to-end test
Kad budeÅ¡ spreman:
â€œidemo BLOK 5â€


